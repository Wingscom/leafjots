# Plan 07-01: Backend Entity CRUD + API Entity Scoping

## Metadata
- **Phase**: 7 — Entity Management
- **Requirements**: ENTY-01, ENTY-02, ENTY-03, ENTY-05
- **Depends on**: None (first plan in phase)
- **Estimated files**: 14 modified, 2 new

## Goal
Create entity CRUD API endpoints and parameterize ALL existing API endpoints to accept `entity_id` instead of hardcoded `get_default()`. After this plan, every API call can be scoped to a specific entity.

## Context

### What exists
- `Entity` model: UUID pk, name, base_currency, deleted_at (soft delete), wallets relationship
- `EntityRepo`: get_default(), get_or_create_default(), get_by_id()
- `entities` table: fully migrated (no new migration needed)
- `tax.py` POST `/calculate` and `reports.py` POST `/generate` already accept optional `entity_id`
- All repos accept entity_id in their methods (list_for_entity, get_all_for_entity, etc.)

### What needs to change
- 14 API endpoints hardcode `get_default()` — must accept `entity_id` query param
- EntityRepo needs list_all, create, update, soft_delete methods
- New entities router with 5 CRUD endpoints
- New Pydantic schemas for entity requests/responses

## Tasks

### Task 1: Extend EntityRepo with CRUD methods
**File**: `src/cryptotax/db/repos/entity_repo.py`

Add these methods to `EntityRepo`:

```python
async def list_all(self) -> list[Entity]:
    """List all non-deleted entities ordered by name."""
    result = await self._session.execute(
        select(Entity)
        .where(Entity.deleted_at.is_(None))
        .order_by(Entity.name)
    )
    return list(result.scalars().all())

async def create(self, name: str, base_currency: str = "VND") -> Entity:
    entity = Entity(name=name, base_currency=base_currency)
    self._session.add(entity)
    await self._session.flush()
    return entity

async def update(self, entity_id: uuid.UUID, **kwargs) -> Optional[Entity]:
    entity = await self.get_by_id(entity_id)
    if entity is None:
        return None
    for key, value in kwargs.items():
        if value is not None and hasattr(entity, key):
            setattr(entity, key, value)
    await self._session.flush()
    return entity

async def soft_delete(self, entity_id: uuid.UUID) -> bool:
    entity = await self.get_by_id(entity_id)
    if entity is None:
        return False
    entity.deleted_at = datetime.utcnow()
    await self._session.flush()
    return True

async def count_wallets(self, entity_id: uuid.UUID) -> int:
    from cryptotax.db.models.wallet import Wallet
    result = await self._session.execute(
        select(func.count(Wallet.id)).where(Wallet.entity_id == entity_id)
    )
    return result.scalar() or 0
```

Import `datetime` and `func` from sqlalchemy at the top.

### Task 2: Create entity Pydantic schemas
**New file**: `src/cryptotax/api/schemas/entities.py`

```python
import uuid
from datetime import datetime
from pydantic import BaseModel


class EntityCreateRequest(BaseModel):
    name: str
    base_currency: str = "VND"


class EntityUpdateRequest(BaseModel):
    name: str | None = None
    base_currency: str | None = None


class EntityResponse(BaseModel):
    id: uuid.UUID
    name: str
    base_currency: str
    wallet_count: int = 0
    created_at: datetime
    updated_at: datetime

    model_config = {"from_attributes": True}


class EntityListResponse(BaseModel):
    entities: list[EntityResponse]
    total: int
```

### Task 3: Create entities API router
**New file**: `src/cryptotax/api/entities.py`

5 endpoints:

| Method | Path | Action |
|--------|------|--------|
| GET | `/api/entities` | List all non-deleted entities with wallet_count |
| POST | `/api/entities` | Create entity |
| GET | `/api/entities/{entity_id}` | Get single entity |
| PATCH | `/api/entities/{entity_id}` | Update entity name/currency |
| DELETE | `/api/entities/{entity_id}` | Soft delete entity |

Implementation pattern: same as other routers — `get_db` dependency, create `EntityRepo(db)`, call repo methods, return Pydantic response.

For `list`: call `repo.list_all()`, then for each entity call `repo.count_wallets(entity.id)` to populate `wallet_count`.

For `delete`: return 204 No Content on success.

### Task 4: Wire entities router into main.py
**File**: `src/cryptotax/api/main.py`

Add import and include_router:
```python
from cryptotax.api.entities import router as entities_router
app.include_router(entities_router)
```

### Task 5: Create resolve_entity dependency helper
**File**: `src/cryptotax/api/deps.py`

Add a reusable helper to resolve entity from query param:

```python
async def resolve_entity(
    entity_id: uuid.UUID | None = Query(None, description="Entity ID (uses default if omitted)"),
    db: AsyncSession = Depends(get_db),
) -> Entity:
    repo = EntityRepo(db)
    if entity_id:
        entity = await repo.get_by_id(entity_id)
        if entity is None:
            raise HTTPException(status_code=404, detail="Entity not found")
        return entity
    entity = await repo.get_or_create_default()
    return entity
```

This dependency replaces all `get_default()` / `get_or_create_default()` calls across routers.

### Task 6: Parameterize wallets.py endpoints
**File**: `src/cryptotax/api/wallets.py`

Replace `entity = await entity_repo.get_or_create_default()` and `entity = await entity_repo.get_default()` with `entity: Entity = Depends(resolve_entity)` in function signature for:
- `add_wallet` — uses entity.id to create wallet
- `add_cex_wallet` — uses entity.id to create wallet
- `list_wallets` — uses entity.id to query wallets

### Task 7: Parameterize transactions.py
**File**: `src/cryptotax/api/transactions.py`

- `list_transactions` — add `entity: Entity = Depends(resolve_entity)` and use `entity.id` in the fallback path (when no wallet_id given)

### Task 8: Parameterize journal.py
**File**: `src/cryptotax/api/journal.py`

- `list_journal` — add entity dependency, use entity.id
- `list_unbalanced` — add entity dependency, use entity.id

### Task 9: Parameterize parser.py
**File**: `src/cryptotax/api/parser.py`

- `parse_test` — add entity dependency, use entity.id
- `parse_wallet` — add entity dependency, use entity.id
- `parse_stats` — add optional `entity_id: uuid.UUID | None = Query(None)` param, scope queries by entity when provided

### Task 10: Parameterize errors.py
**File**: `src/cryptotax/api/errors.py`

- `list_errors` — add optional entity_id query param for filtering
- `error_summary` — add optional entity_id query param for filtering
- `retry_error_group` — use entity dependency
- `retry_error` — use entity dependency

### Task 11: Parameterize accounts.py
**File**: `src/cryptotax/api/accounts.py`

- `list_accounts` — add entity dependency, use entity.id

### Task 12: Parameterize tax.py GET endpoints
**File**: `src/cryptotax/api/tax.py`

Already done for POST `/calculate`. Add `entity_id: uuid.UUID | None = Query(None)` to:
- `get_realized_gains` — scope ClosedLotRecord query by entity_id
- `get_open_lots` — scope OpenLotRecord query by entity_id
- `get_tax_summary` — scope queries by entity_id

### Task 13: Parameterize reports.py list endpoint
**File**: `src/cryptotax/api/reports.py`

Already done for POST `/generate`. Add `entity_id: uuid.UUID | None = Query(None)` to:
- `list_reports` — filter Report records by entity_id when provided

### Task 14: Write backend tests
**File**: `tests/unit/test_entity_api.py` (new)

Test:
1. `POST /api/entities` — create entity, verify response fields
2. `GET /api/entities` — list returns created entities with wallet_count
3. `GET /api/entities/{id}` — get by ID
4. `PATCH /api/entities/{id}` — rename entity
5. `DELETE /api/entities/{id}` — soft delete, verify excluded from list
6. Entity scoping: `GET /api/wallets?entity_id=X` returns only X's wallets
7. Entity scoping: `GET /api/journal?entity_id=X` returns only X's entries
8. Entity scoping: `GET /api/accounts?entity_id=X` returns only X's accounts
9. Entity scoping: `GET /api/tax/realized-gains?entity_id=X` returns only X's records
10. Entity scoping: `GET /api/errors?entity_id=X` returns only X's errors
11. Default entity: omitting entity_id uses default entity (backward compatible)

**Note on tax scoping**: `ClosedLotRecord` and `OpenLotRecord` both have `entity_id` FK columns (verified in `src/cryptotax/db/models/capital_gains.py`), so Task 12 scoping works by adding `.where(ClosedLotRecord.entity_id == entity_id)` etc.

## Verification
1. `python -m pytest tests/ -x -q` — all tests pass (existing + new)
2. `ruff check src/` — 0 lint errors
3. Code scan: `grep -r "get_default\|get_or_create_default" src/cryptotax/api/` should return matches ONLY in `deps.py` (resolve_entity helper). Zero direct calls in wallets.py, transactions.py, journal.py, parser.py, errors.py, accounts.py, tax.py, reports.py.
4. Manual: `GET /api/entities` returns entity list
5. Manual: `GET /api/wallets?entity_id=<uuid>` scopes wallets by entity
6. Manual: All endpoints without entity_id still work (backward compatible)

## Risks
- **Backward compatibility**: All entity_id params are optional with default fallback — existing API calls work unchanged
- **N+1 query on wallet_count**: For list_all, counting wallets per entity is a separate query. Acceptable for small entity count (<100). Optimize with subquery/join if needed later.
