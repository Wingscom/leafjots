# Plan 07-02: Frontend Entity Selector + Page Scoping

## Metadata
- **Phase**: 7 â€” Entity Management
- **Requirements**: ENTY-04, ENTY-06, ENTY-07
- **Depends on**: 07-01 (backend entity CRUD + API scoping must exist)
- **Estimated files**: 14 modified, 4 new

## Goal
Add a global entity selector dropdown to the UI that persists across page navigations, and update all pages to pass the selected entity_id to API calls. Create an entity management page for CRUD operations.

## Context

### What exists (after 07-01)
- `GET /api/entities` returns entity list with wallet_count
- All API endpoints accept optional `entity_id` query param
- Frontend: 9 pages, 8 hook files, 8 API files â€” none pass entity_id yet
- `web/src/api/client.ts` â€” generic `apiFetch` wrapper
- Layout sidebar has nav items, no entity selector

### What needs to change
- New EntityContext (React Context) for global entity state
- Entity selector dropdown in sidebar header
- All hooks pass entity_id from context to API calls
- All API functions accept optional entity_id parameter
- New Entities management page
- Dashboard stats scoped to selected entity

## Tasks

### Task 1: Create entity API client
**New file**: `web/src/api/entities.ts`

```typescript
import { apiFetch } from './client'

export interface Entity {
  id: string
  name: string
  base_currency: string
  wallet_count: number
  created_at: string
  updated_at: string
}

export interface EntityList {
  entities: Entity[]
  total: number
}

export interface EntityCreateRequest {
  name: string
  base_currency?: string
}

export interface EntityUpdateRequest {
  name?: string
  base_currency?: string
}

export async function listEntities(): Promise<EntityList> {
  return apiFetch('/entities')
}

export async function createEntity(data: EntityCreateRequest): Promise<Entity> {
  return apiFetch('/entities', {
    method: 'POST',
    body: JSON.stringify(data),
  })
}

export async function getEntity(id: string): Promise<Entity> {
  return apiFetch(`/entities/${id}`)
}

export async function updateEntity(id: string, data: EntityUpdateRequest): Promise<Entity> {
  return apiFetch(`/entities/${id}`, {
    method: 'PATCH',
    body: JSON.stringify(data),
  })
}

export async function deleteEntity(id: string): Promise<void> {
  return apiFetch(`/entities/${id}`, { method: 'DELETE' })
}
```

### Task 2: Create useEntities hook
**New file**: `web/src/hooks/useEntities.ts`

TanStack Query hooks:
- `useEntities()` â€” calls `listEntities()`, query key `['entities']`
- `useCreateEntity()` â€” mutation, invalidates `['entities']` on success
- `useUpdateEntity()` â€” mutation, invalidates `['entities']` on success
- `useDeleteEntity()` â€” mutation, invalidates `['entities']` on success

### Task 3: Create EntityContext
**New file**: `web/src/context/EntityContext.tsx`

```typescript
import { createContext, useContext, useState, useEffect, ReactNode } from 'react'

interface EntityContextValue {
  entityId: string | null
  setEntityId: (id: string | null) => void
}

const EntityContext = createContext<EntityContextValue>({
  entityId: null,
  setEntityId: () => {},
})

export function EntityProvider({ children }: { children: ReactNode }) {
  const [entityId, setEntityId] = useState<string | null>(() => {
    return localStorage.getItem('selectedEntityId')
  })

  useEffect(() => {
    if (entityId) {
      localStorage.setItem('selectedEntityId', entityId)
    } else {
      localStorage.removeItem('selectedEntityId')
    }
  }, [entityId])

  return (
    <EntityContext.Provider value={{ entityId, setEntityId }}>
      {children}
    </EntityContext.Provider>
  )
}

export function useEntity() {
  return useContext(EntityContext)
}
```

Key behaviors:
- Persists selected entity_id to localStorage
- On mount, reads from localStorage (survives page refresh)
- `null` means "use default entity" (backward compatible)

### Task 4: Wrap App with EntityProvider
**File**: `web/src/App.tsx`

Wrap the `<Routes>` or the `<QueryClientProvider>` with `<EntityProvider>`:
```tsx
<QueryClientProvider client={queryClient}>
  <EntityProvider>
    <BrowserRouter>
      <Routes>...</Routes>
    </BrowserRouter>
  </EntityProvider>
</QueryClientProvider>
```

Also add `/entities` route:
```tsx
<Route path="/entities" element={<Entities />} />
```

### Task 5: Create EntitySelector component
**New file**: `web/src/components/EntitySelector.tsx`

A dropdown/select in the sidebar that:
1. Fetches entities via `useEntities()`
2. Shows current selection (from EntityContext)
3. On change, calls `setEntityId(newId)`
4. Shows entity name + base currency
5. Auto-selects first entity if none selected (on initial load when entities exist)
6. **Stale localStorage guard**: After fetching entity list, validate that the current `entityId` from context exists in the fetched list. If the stored entity was soft-deleted or no longer exists, clear it (`setEntityId(null)`) and auto-select the first available entity. This ensures Success Criterion 5 (soft-deleted entities disappear from selector) works even after a page refresh with a stale localStorage value.

Styling: Tailwind, matches sidebar theme (dark bg). Use a `<select>` or custom dropdown.

### Task 6: Add EntitySelector to Layout sidebar
**File**: `web/src/components/Layout.tsx`

- Import `EntitySelector`
- Place it in the sidebar between the header (title/version) and the nav items list
- Add "Entities" nav item (icon: `Building2` from lucide-react) linking to `/entities`

### Task 7: Update API client functions to accept entity_id

Update ALL API files to pass entity_id as query param when provided:

**`web/src/api/wallets.ts`**:
- `listWallets(entityId?: string)` â†’ append `?entity_id=X` to URL
- `addWallet(data, entityId?)` â†’ append entity_id to URL or include in body
- `addCexWallet(data, entityId?)` â†’ same

**`web/src/api/transactions.ts`**:
- `listTransactions(params, entityId?)` â†’ add to query params

**`web/src/api/journal.ts`**:
- `listJournal(params, entityId?)` â†’ add to query params
- `listUnbalanced(entityId?)` â†’ add to query params

**`web/src/api/accounts.ts`**:
- `listAccounts(entityId?)` â†’ add to query params

**`web/src/api/parse.ts`**:
- `getParseStats(entityId?)` â†’ add to query params
- `testParse(data, entityId?)` â†’ add entity_id to body
- `parseWallet(walletId, entityId?)` â†’ add to query params

**`web/src/api/errors.ts`**:
- `listErrors(params, entityId?)` â†’ add to query params
- `getErrorSummary(entityId?)` â†’ add to query params

**`web/src/api/tax.ts`**:
- Already has entity_id in calculate. Add to: `getRealizedGains(entityId?)`, `getOpenLots(entityId?)`, `getTaxSummary(entityId?)`

**`web/src/api/reports.ts`**:
- Already has entity_id in generate. Add to: `listReports(entityId?)`

Helper pattern â€” add a utility function in `client.ts`:
```typescript
export function withEntityId(path: string, entityId?: string): string {
  if (!entityId) return path
  const sep = path.includes('?') ? '&' : '?'
  return `${path}${sep}entity_id=${entityId}`
}
```

### Task 8: Update all hooks to pass entityId from context

Each hook reads `entityId` from `useEntity()` context and passes to API calls:

**`web/src/hooks/useWallets.ts`**:
```typescript
export function useWallets() {
  const { entityId } = useEntity()
  return useQuery({
    queryKey: ['wallets', entityId],
    queryFn: () => listWallets(entityId ?? undefined),
  })
}
```

Same pattern for ALL query hooks:
- `useTransactions.ts` â€” add entityId to query key + API call
- `useJournal.ts` â€” add entityId to query key + API call
- `useAccounts.ts` â€” add entityId to query key + API call
- `useParser.ts` â€” add entityId to stats query key + API call
- `useErrors.ts` â€” add entityId to query key + API call
- `useTax.ts` â€” add entityId where missing (calculate already has it)
- `useReports.ts` â€” add entityId where missing

**Mutation hooks must also pass entityId**:
- `useWallets.ts` â†’ `useAddWallet()` and `useAddCEXWallet()` mutations must read `entityId` from `useEntity()` and pass it to `addWallet(data, entityId)` / `addCexWallet(data, entityId)`. Without this, creating a wallet while entity B is selected would assign it to the default entity instead.
- `useParser.ts` â†’ `useTestParse()` and `useParseWallet()` mutations must pass entityId
- `useErrors.ts` â†’ `useRetryError()` and `useRetryErrorGroup()` mutations must pass entityId
- `useTax.ts` â†’ `useCalculateTax()` already passes entity_id (keep as-is)
- `useReports.ts` â†’ `useGenerateReport()` already passes entity_id (keep as-is)

**Critical**: Adding entityId to query keys ensures TanStack Query automatically refetches data when entity changes. This is the key mechanism that makes switching entities instant.

### Task 9: Create Entities management page
**New file**: `web/src/pages/Entities.tsx`

Layout:
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Entities                      [+ New]    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Name        â”‚ Currency â”‚ Wallets â”‚ Actionsâ”‚
â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”‚
â”‚ My Fund     â”‚ VND      â”‚ 3       â”‚ âœï¸ ğŸ—‘ï¸ â”‚
â”‚ Individual  â”‚ USD      â”‚ 1       â”‚ âœï¸ ğŸ—‘ï¸ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

Features:
- Table showing all entities with name, base_currency, wallet_count
- "New Entity" button opens inline form or modal (name + currency select)
- Edit button â†’ inline edit or modal
- Delete button â†’ confirmation dialog, then soft delete
- After create/delete, entity list and selector both refresh (via query invalidation)

### Task 10: Update Dashboard to show entity-scoped stats
**File**: `web/src/pages/Dashboard.tsx`

Currently Dashboard fetches:
- Wallet count â†’ `useWallets()`
- Parse stats â†’ `useParseStats()`
- Tax summary â†’ `useTaxSummary()`

After Task 8, these hooks already pass entityId from context. So the Dashboard automatically shows entity-scoped data.

Additional change: Add selected entity name as a subtitle or chip on the dashboard, e.g.:
```
Dashboard â€” My Fund
```

### Task 11: TypeScript compilation check + frontend tests
Verify:
- `cd web && npx tsc --noEmit` â€” 0 errors
- All pages render correctly with entity selector
- Switching entities causes all data to refresh

## Verification
1. `cd web && npx tsc --noEmit` â€” 0 TypeScript errors
2. Code scan: `grep -r "useEntity" web/src/hooks/` should match every hook file except `useEntities.ts`. Any file missing this call was skipped.
3. Entity selector appears in sidebar, persists across navigation
4. Switching entity causes all pages to show different data
5. New entity creation appears in selector immediately
6. Soft-deleted entity disappears from selector (even after page refresh with stale localStorage)
7. localStorage persistence: refresh page, same entity selected
8. No entity_id (fresh state) falls back to default entity
9. Creating a wallet while entity B is selected assigns it to entity B (not default)

## Risks
- **Query cache invalidation**: TanStack Query uses entityId in query keys, so switching entities will refetch. This is correct behavior but may cause brief loading states â€” acceptable.
- **First load UX**: If no entities exist, auto-create "Default" via backend get_or_create_default(). Selector shows it. User can rename later.
