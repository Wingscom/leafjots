# Plan 11-01: Import UI Polish -- Progress, Summary, Error Detail

## Metadata
- **Phase**: 11 — Import UI Polish
- **Requirements**: IMUI-02, IMUI-03, IMUI-04
- **Depends on**: Phase 10 (all parsers complete)
- **Estimated files**: 3 modified backend, 5 modified/new frontend

## Goal
Upgrade the import experience to show real-time parsing progress, a post-import summary with grouped operation counts, and an expandable error detail view for failed rows.

## Context

### What exists (after Phase 10)
- `POST /api/imports/upload` → stores raw CSV rows
- `POST /api/imports/{id}/parse` → parses all rows synchronously, returns {total, parsed, errors, skipped}
- `GET /api/imports` → list imports with row_count, parsed_count, error_count, status
- `GET /api/imports/{id}` → detail with all rows
- `GET /api/imports/{id}/rows?status=` → rows filtered by status
- Import page: upload area, history table with Parse button
- BinanceCsvParser handles all 36 operation types

### What needs to change
1. **Auto-parse after upload**: After successful upload, automatically trigger parse
2. **Progress indicator**: While parsing, show a progress bar or row count indicator (poll for status)
3. **Import summary**: After parse completes, show grouped operation counts (e.g., "12 Spot Trades, 5 Converts, 180 Funding Fees")
4. **Error detail view**: Click on an import to see failed rows with raw CSV data and error messages

## Tasks

### Task 1: Add operation summary endpoint
**File**: `src/cryptotax/api/imports.py` (modify)

New endpoint:
```python
@router.get("/{import_id}/summary")
async def get_import_summary(import_id: uuid.UUID, db: DbDep) -> ImportSummaryResponse:
    """Get parse summary: operation counts, status breakdown."""
    repo = CsvImportRepo(db)
    csv_import = await repo.get_by_id(import_id)
    if csv_import is None:
        raise HTTPException(status_code=404, detail="Import not found")

    rows = csv_import.rows
    # Group by operation
    op_counts: dict[str, int] = {}
    status_counts: dict[str, int] = {"parsed": 0, "error": 0, "skipped": 0, "pending": 0}
    for row in rows:
        op_counts[row.operation] = op_counts.get(row.operation, 0) + 1
        status_counts[row.status] = status_counts.get(row.status, 0) + 1

    return ImportSummaryResponse(
        import_id=csv_import.id,
        total=csv_import.row_count,
        operation_counts=op_counts,
        status_counts=status_counts,
    )
```

**File**: `src/cryptotax/api/schemas/imports.py` (modify)
```python
class ImportSummaryResponse(BaseModel):
    import_id: uuid.UUID
    total: int
    operation_counts: dict[str, int]
    status_counts: dict[str, int]
```

### Task 2: Add error rows endpoint
**File**: `src/cryptotax/api/imports.py` (modify)

Already exists: `GET /{import_id}/rows?status=error` returns error rows. Ensure the response includes error_message.

Verify CsvImportRowResponse already has error_message field — it does (from Phase 8).

### Task 3: Add API client functions for summary and error rows
**File**: `web/src/api/imports.ts` (modify)

```typescript
export interface ImportSummary {
  import_id: string
  total: number
  operation_counts: Record<string, number>
  status_counts: Record<string, number>
}

export interface CsvImportRow {
  id: string
  row_number: number
  utc_time: string
  account: string
  operation: string
  coin: string
  change: string
  remark: string | null
  status: string
  error_message: string | null
}

export async function getImportSummary(importId: string): Promise<ImportSummary> {
  return apiFetch(`/imports/${importId}/summary`)
}

export async function getImportRows(importId: string, status?: string): Promise<CsvImportRow[]> {
  const path = status ? `/imports/${importId}/rows?status=${status}` : `/imports/${importId}/rows`
  return apiFetch(path)
}
```

### Task 4: Add hooks for summary and rows
**File**: `web/src/hooks/useImports.ts` (modify)

```typescript
export function useImportSummary(importId: string | null) {
  return useQuery({
    queryKey: [...IMPORTS_KEY, 'summary', importId],
    queryFn: () => getImportSummary(importId!),
    enabled: !!importId,
  })
}

export function useImportRows(importId: string | null, status?: string) {
  return useQuery({
    queryKey: [...IMPORTS_KEY, 'rows', importId, status],
    queryFn: () => getImportRows(importId!, status),
    enabled: !!importId,
  })
}
```

### Task 5: Auto-parse after upload + polling progress
**File**: `web/src/pages/Imports.tsx` (modify)

After upload succeeds, automatically trigger parse:
```tsx
const uploadMutation = useUploadCsv()
const parseMutation = useParseImport()

const handleUpload = useCallback((file: File) => {
  if (!entityId) return
  uploadMutation.mutate({ file, entityId, exchange }, {
    onSuccess: (data) => {
      // Auto-trigger parse
      parseMutation.mutate(data.import_id)
    },
  })
}, [entityId, exchange])
```

While parsing, show a progress state on the import row:
- Upload button changes to "Uploading..." → "Parsing..." → shows result
- After parse mutation completes, show the summary inline

### Task 6: Import summary panel
**File**: `web/src/pages/Imports.tsx` (modify)

When clicking an import row (or after parse completes), show a summary panel below the row:

```tsx
function ImportSummary({ importId }: { importId: string }) {
  const { data } = useImportSummary(importId)
  if (!data) return <div className="text-sm text-gray-400">Loading summary...</div>

  return (
    <div className="bg-gray-50 p-4 rounded-lg mt-2">
      <div className="grid grid-cols-4 gap-4 mb-3">
        <StatCard label="Total Rows" value={data.total} />
        <StatCard label="Parsed" value={data.status_counts.parsed || 0} color="green" />
        <StatCard label="Errors" value={data.status_counts.error || 0} color="red" />
        <StatCard label="Skipped" value={data.status_counts.skipped || 0} color="yellow" />
      </div>
      <h4 className="text-sm font-medium text-gray-700 mb-2">Operations</h4>
      <div className="flex flex-wrap gap-2">
        {Object.entries(data.operation_counts)
          .sort(([,a], [,b]) => b - a)
          .map(([op, count]) => (
            <span key={op} className="text-xs bg-white border rounded-full px-2 py-1">
              {op}: {count}
            </span>
          ))}
      </div>
    </div>
  )
}
```

### Task 7: Error detail view
**File**: `web/src/pages/Imports.tsx` (modify)

Add an expandable section to view error rows:

```tsx
function ErrorRows({ importId }: { importId: string }) {
  const { data: rows } = useImportRows(importId, 'error')
  if (!rows || rows.length === 0) return <p className="text-sm text-gray-400">No errors</p>

  return (
    <div className="mt-3">
      <h4 className="text-sm font-medium text-red-700 mb-2">Failed Rows ({rows.length})</h4>
      <div className="space-y-2 max-h-64 overflow-y-auto">
        {rows.map((row) => (
          <div key={row.id} className="bg-red-50 border border-red-200 rounded p-3 text-xs">
            <div className="flex justify-between mb-1">
              <span className="font-mono">Row #{row.row_number}</span>
              <span className="text-red-600">{row.operation}</span>
            </div>
            <div className="grid grid-cols-4 gap-2 text-gray-600 mb-2">
              <span>{row.utc_time}</span>
              <span>{row.account}</span>
              <span>{row.coin}</span>
              <span>{row.change}</span>
            </div>
            {row.error_message && (
              <div className="text-red-700 bg-red-100 rounded p-2 font-mono break-all">
                {row.error_message}
              </div>
            )}
          </div>
        ))}
      </div>
    </div>
  )
}
```

### Task 8: Wire up expandable import detail
**File**: `web/src/pages/Imports.tsx` (modify)

Make import rows clickable to expand/collapse detail view:

```tsx
function ImportRow({ imp }: { imp: CsvImport }) {
  const [expanded, setExpanded] = useState(false)
  // ... existing parse button logic

  return (
    <>
      <tr className="border-b border-gray-50 hover:bg-gray-50 cursor-pointer" onClick={() => setExpanded(!expanded)}>
        {/* existing cells + chevron indicator */}
      </tr>
      {expanded && (
        <tr>
          <td colSpan={8} className="p-4 bg-gray-50">
            <ImportSummary importId={imp.id} />
            {imp.error_count > 0 && <ErrorRows importId={imp.id} />}
          </td>
        </tr>
      )}
    </>
  )
}
```

### Task 9: TypeScript check + visual verification
- `cd web && npx tsc --noEmit` — 0 errors
- Backend tests still pass
- Visual: upload file → auto-parses → shows summary → click to expand → see errors

## Verification
1. `cd web && npx tsc --noEmit` — 0 TypeScript errors
2. `python -m pytest tests/ -x -q` — all tests pass (backend unchanged except new endpoint)
3. Upload a CSV → automatically triggers parse (not manual Parse button needed)
4. While parsing: shows "Parsing..." indicator
5. After parse: row updates with parsed_count, error_count, status
6. Click import row → expands to show summary panel with operation breakdown
7. Error rows visible with raw CSV data + error message
8. GET /api/imports/{id}/summary returns operation_counts and status_counts

## Risks
- **Synchronous parsing**: Currently parse runs synchronously in one request. For large CSVs (1000+ rows) this may timeout. Acceptable for now since the real CSV is 340 rows. Future: use Celery task.
- **Polling vs WebSocket**: No real-time progress — the parse completes in one request. If it were async, we'd need polling. For now, the mutation just waits for response.
